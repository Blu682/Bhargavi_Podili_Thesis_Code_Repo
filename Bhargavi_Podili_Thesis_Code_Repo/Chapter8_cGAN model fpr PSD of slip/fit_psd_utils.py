# -*- coding: utf-8 -*-
"""fit_psd_utils.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mtj99gluNy_mO5tiN-sshBYTd4NaGXAa
"""

# Commented out IPython magic to ensure Python compatibility.
# # 5 #
# %%writefile fit_psd_utils.py
# import numpy as np
# from scipy.optimize import minimize
# from data_utils import unpad_psd_origin_centered, unpad_kx_kz_origin_centered
# 
# def fit_psd(padded_psd, padded_kx, padded_kz, D, L, W, true_h, true_w):
#     psd = unpad_psd_origin_centered(padded_psd, int(true_h), int(true_w))
#     kx, kz = unpad_kx_kz_origin_centered(padded_kx, padded_kz, true_w, true_h)
#     if psd.shape != (len(kz), len(kx)):
#         return [1e-4, 1e-4, 2.5]  # fallback default
#     kx_grid, kz_grid = np.meshgrid(kx, kz, indexing='ij')
#     kx_flat = kx_grid.flatten()
#     kz_flat = kz_grid.flatten()
#     psd_flat = psd.flatten()
#     def loss(params):
#         kcx, kcy, gamma = params
#         model = (D * L * W) / np.sqrt(1 + ((kx_flat / kcx) ** 2 + (kz_flat / kcy) ** 2) ** gamma)
#         return np.mean((model - psd_flat) ** 2)
#     initial = [1e-4, 1e-4, 2.0]
#     bounds = [(1e-6, 1e-2), (1e-6, 1e-2), (1.5, 6.0)]
#     result = minimize(loss, initial, bounds=bounds, method='L-BFGS-B')
#     return result.x
# 
# def compute_all_psd_parameters(psds, conds, kx_list, kz_list):
#     fitted_params = []
#     for i in range(len(psds)):
#         psd = psds[i]
#         L, W, Nx, Nz, Dmean, Mw = conds[i][:6]
#         D = Dmean
#         padded_kx = np.array(kx_list[i])
#         padded_kz = np.array(kz_list[i])
#         true_h, true_w = int(conds[i][3]), int(conds[i][2])
#         kcx, kcy, gamma = fit_psd(psd, padded_kx, padded_kz, D, L, W, true_h, true_w)
#         fitted_params.append([kcx, kcy, gamma])
#     return np.array(fitted_params)
# 
#