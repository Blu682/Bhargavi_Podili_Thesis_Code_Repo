# -*- coding: utf-8 -*-
"""data_utils.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mtj99gluNy_mO5tiN-sshBYTd4NaGXAa
"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile data_utils.py
# import numpy as np
# import tensorflow as tf
# import scipy.io
# 
# def pad_psd_origin_centered(psd, h, w, target_h=64, target_w=64):
#     # Ensure the max value (origin) is at index (31,31) in Q2 (Python index)
#     max_idx = tf.argmax(tf.reshape(psd, [-1]))
#     max_row = max_idx // w
#     max_col = max_idx % w
#     rows_pre = 31 - max_row
#     cols_pre = 31 - max_col
#     padded = tf.pad(psd, [[rows_pre, target_h - h - rows_pre],
#      [cols_pre, target_w - w - cols_pre]], mode='CONSTANT')
#     return padded
# 
# def unpad_psd_origin_centered(padded, h, w):
#     rows_pre = 31 - (h // 2)
#     cols_pre = 31 - (w // 2)
#     return padded[rows_pre:rows_pre + h, cols_pre:cols_pre + w]
# 
# def pad_kx_kz_origin_centered(kx, kz, w, h, target_w=64, target_h=64):
#     kx = np.asarray(kx)
#     kz = np.asarray(kz)
#     # Find effective origin index (closest to zero)
#     kx_origin_idx = np.argmin(np.abs(kx))
#     kz_origin_idx = np.argmin(np.abs(kz))
#     dkx = kx[1] - kx[0]
#     dkz = kz[1] - kz[0]
#     cols_pre = 31 - kx_origin_idx
#     rows_pre = 31 - kz_origin_idx
#     kx_new = np.zeros((target_w,), dtype=np.float32)
#     kz_new = np.zeros((target_h,), dtype=np.float32)
#     kx_trimmed = kx[:min(w, target_w - cols_pre)]
#     kz_trimmed = kz[:min(h, target_h - rows_pre)]
#     kx_new[cols_pre:cols_pre + len(kx_trimmed)] = kx_trimmed
#     kz_new[rows_pre:rows_pre + len(kz_trimmed)] = kz_trimmed
#     for i in range(cols_pre - 1, -1, -1):
#         kx_new[i] = kx_new[i + 1] - abs(dkx)
#     for i in range(cols_pre + len(kx_trimmed), target_w):
#         kx_new[i] = kx_new[i - 1] + abs(dkx)
#     for i in range(rows_pre - 1, -1, -1):
#         kz_new[i] = kz_new[i + 1] - abs(dkz)
#     for i in range(rows_pre + len(kz_trimmed), target_h):
#         kz_new[i] = kz_new[i - 1] + abs(dkz)
#     return kx_new, kz_new
# 
# def unpad_kx_kz_origin_centered(kx_padded, kz_padded, w, h):
#     cols_pre = 31 - (w // 2)
#     rows_pre = 31 - (h // 2)
#     return kx_padded[cols_pre:cols_pre + w], kz_padded[rows_pre:rows_pre + h]
# 
# def load_matlab_psd(file_path):
#     mat_data = scipy.io.loadmat(file_path)
#     entries = mat_data['ModelDATAfinal']
#     psd_list, cond_list, kx_list, kz_list = [], [], [], []
#     for entry in entries:
#         psd = np.array(entry[0]['PSD'], dtype=np.float32)
#         L = float(entry[0]['L'].item())
#         W = float(entry[0]['W'].item())
#         Nx = int(entry[0]['Nx'].item())
#         Nz = int(entry[0]['Nz'].item())
#         Dmean = float(entry[0]['Dmean'].item())
#         Mw = float(entry[0]['Mw'].item())
#         Dep = float(entry[0]['Dep'].item())
#         dx, dz = L / Nx, W / Nz
#         Nyq_kx, Nyq_kz = 1 / dx, 1 / dz
#         dkx, dkz = 1 / (Nx * dx), 1 / (Nz * dz)
#         kx = np.arange(-Nyq_kx / 2, Nyq_kx / 2, dkx) if Nx % 2 == 0 else np.linspace(-Nyq_kx / 2, Nyq_kx / 2, Nx)
#         kz = np.arange(-Nyq_kz / 2, Nyq_kz / 2, dkz) if Nz % 2 == 0 else np.linspace(-Nyq_kz / 2, Nyq_kz / 2, Nz)
#         kx, kz = kx / 1000.0, kz / 1000.0
#         psd_tensor = tf.convert_to_tensor(psd, dtype=tf.float32)
#         padded = pad_psd_origin_centered(psd_tensor, Nz, Nx).numpy()
#         kx_padded, kz_padded = pad_kx_kz_origin_centered(kx, kz, Nx, Nz)
#         psd_list.append(padded)
#         cond_list.append([L, W, Nx, Nz, Dmean, Mw, Dep])
#         kx_list.append(kx_padded)
#         kz_list.append(kz_padded)
#     psd_array = np.array(psd_list)
#     cond_array = np.array(cond_list)
#     max_vals = np.max(psd_array, axis=(1, 2), keepdims=True)
#     psd_array /= (max_vals + 1e-8)
#     return psd_array, cond_array, kx_list, kz_list
#